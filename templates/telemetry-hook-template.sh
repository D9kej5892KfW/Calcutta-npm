#!/bin/bash
# Claude Code Telemetry Hook - Multi-Project Template
# Generated by agent-telemetry connect-project.sh
# Sends telemetry data to centralized Loki server

# Configuration (populated by connect-project script)
PROJECT_NAME="{{PROJECT_NAME}}"
PROJECT_PATH="{{PROJECT_PATH}}"
TELEMETRY_SERVER_URL="{{TELEMETRY_SERVER_URL}}"
TELEMETRY_ENABLED={{TELEMETRY_ENABLED}}

# Read JSON input from stdin
JSON_INPUT=$(cat)

# Get current project path
CURRENT_PATH="${PWD}"

# Only activate telemetry in this specific project
if [[ "$CURRENT_PATH" != *"$PROJECT_NAME"* ]]; then
    echo '{"continue": true}'
    exit 0
fi

# Check if telemetry is enabled for this project
if [[ "$TELEMETRY_ENABLED" != "true" ]]; then
    echo '{"continue": true}'
    exit 0
fi

# Extract data from JSON input
TIMESTAMP=$(date -Iseconds)
RESOLVED_PROJECT_NAME=$(basename "$CURRENT_PATH")

# Parse Claude Code's JSON structure
TOOL_NAME=$(echo "$JSON_INPUT" | jq -r '.tool_name // "unknown"' 2>/dev/null || echo "unknown")
SESSION_ID=$(echo "$JSON_INPUT" | jq -r '.session_id // "unknown"' 2>/dev/null || echo "unknown")
HOOK_EVENT=$(echo "$JSON_INPUT" | jq -r '.hook_event_name // "unknown"' 2>/dev/null || echo "unknown")

# Enhanced Phase 3: SuperClaude Context Detection
detect_superclaude_context() {
    local input_text="$1"
    local personas=""
    local flags=""
    local commands=""
    local mcp_servers=""
    local reasoning_level="none"
    local workflow_type="standard"
    
    # Detect SuperClaude commands
    if echo "$input_text" | grep -qE '/(analyze|build|implement|improve|design|task|troubleshoot|explain|document|cleanup|test|git|estimate|index|load|spawn)'; then
        commands=$(echo "$input_text" | grep -oE '/(analyze|build|implement|improve|design|task|troubleshoot|explain|document|cleanup|test|git|estimate|index|load|spawn)' | tr '\n' ',' | sed 's/,$//')
        workflow_type="superclaude"
    fi
    
    # Detect personas
    if echo "$input_text" | grep -qE -- '--persona-(architect|frontend|backend|analyzer|security|mentor|refactorer|performance|qa|devops|scribe)'; then
        personas=$(echo "$input_text" | grep -oE -- '--persona-(architect|frontend|backend|analyzer|security|mentor|refactorer|performance|qa|devops|scribe)' | tr '\n' ',' | sed 's/,$//')
    fi
    
    # Detect reasoning levels
    if echo "$input_text" | grep -qE -- '--ultrathink'; then
        reasoning_level="ultra"
    elif echo "$input_text" | grep -qE -- '--think-hard'; then
        reasoning_level="hard"
    elif echo "$input_text" | grep -qE -- '--think'; then
        reasoning_level="standard"
    fi
    
    # Detect MCP server flags
    if echo "$input_text" | grep -qE -- '--(seq|sequential|c7|context7|magic|play|playwright|all-mcp)'; then
        mcp_servers=$(echo "$input_text" | grep -oE -- '--(seq|sequential|c7|context7|magic|play|playwright|all-mcp)' | tr '\n' ',' | sed 's/,$//')
    fi
    
    # Detect general flags
    if echo "$input_text" | grep -qE -- '--(uc|ultracompressed|plan|validate|safe-mode|verbose|delegate|wave-mode|loop|introspect)'; then
        flags=$(echo "$input_text" | grep -oE -- '--(uc|ultracompressed|plan|validate|safe-mode|verbose|delegate|wave-mode|loop|introspect)' | tr '\n' ',' | sed 's/,$//')
    fi
    
    # Return JSON structure
    jq -n \
        --arg commands "$commands" \
        --arg personas "$personas" \
        --arg reasoning_level "$reasoning_level" \
        --arg mcp_servers "$mcp_servers" \
        --arg flags "$flags" \
        --arg workflow_type "$workflow_type" \
        '{
            commands: $commands,
            personas: $personas,
            reasoning_level: $reasoning_level,
            mcp_servers: $mcp_servers,
            flags: $flags,
            workflow_type: $workflow_type
        }'
}

# Extract user prompt context from transcript if available
USER_PROMPT=""
TRANSCRIPT_PATH=$(echo "$JSON_INPUT" | jq -r '.transcript_path // ""' 2>/dev/null || echo "")
if [[ -n "$TRANSCRIPT_PATH" && -f "$TRANSCRIPT_PATH" ]]; then
    # Get the last user message from transcript
    USER_PROMPT=$(tail -20 "$TRANSCRIPT_PATH" | grep '"role":"user"' | tail -1 | jq -r '.content // ""' 2>/dev/null || echo "")
fi

# Detect SuperClaude context
SUPERCLAUDE_CONTEXT=$(detect_superclaude_context "$USER_PROMPT" || echo '{}')

# Tool-specific processing
process_tool_specific_data() {
    local tool="$1"
    local tool_input="$2"
    
    case "$tool" in
        "Read"|"Write"|"Edit"|"MultiEdit")
            # Extract file path and operation type
            FILE_PATH=$(echo "$tool_input" | jq -r '.file_path // .path // ""' 2>/dev/null || echo "")
            if [[ -n "$FILE_PATH" ]]; then
                # Check if file is outside project scope
                OUTSIDE_SCOPE="false"
                if [[ "$FILE_PATH" != "$CURRENT_PATH"* ]]; then
                    OUTSIDE_SCOPE="true"
                fi
                
                # Get file size if it exists
                FILE_SIZE=0
                if [[ -f "$FILE_PATH" ]]; then
                    FILE_SIZE=$(stat -f%z "$FILE_PATH" 2>/dev/null || stat -c%s "$FILE_PATH" 2>/dev/null || echo 0)
                fi
                
                echo "{\"file_path\":\"$FILE_PATH\",\"size_bytes\":$FILE_SIZE,\"outside_project_scope\":$OUTSIDE_SCOPE}"
            else
                echo "{}"
            fi
            ;;
        "Bash")
            # Extract command
            COMMAND=$(echo "$tool_input" | jq -r '.command // ""' 2>/dev/null || echo "")
            DESCRIPTION=$(echo "$tool_input" | jq -r '.description // ""' 2>/dev/null || echo "")
            echo "{\"command\":\"$COMMAND\",\"description\":\"$DESCRIPTION\"}"
            ;;
        "Grep"|"Glob")
            # Extract search pattern
            PATTERN=$(echo "$tool_input" | jq -r '.pattern // ""' 2>/dev/null || echo "")
            SEARCH_PATH=$(echo "$tool_input" | jq -r '.path // ""' 2>/dev/null || echo "")
            echo "{\"pattern\":\"$PATTERN\",\"path\":\"$SEARCH_PATH\"}"
            ;;
        "Task")
            # Extract delegation info
            SUBAGENT_TYPE=$(echo "$tool_input" | jq -r '.subagent_type // ""' 2>/dev/null || echo "")
            DESCRIPTION=$(echo "$tool_input" | jq -r '.description // ""' 2>/dev/null || echo "")
            echo "{\"subagent_type\":\"$SUBAGENT_TYPE\",\"description\":\"$DESCRIPTION\"}"
            ;;
        "WebFetch"|"WebSearch")
            # Extract URL/query
            URL=$(echo "$tool_input" | jq -r '.url // ""' 2>/dev/null || echo "")
            QUERY=$(echo "$tool_input" | jq -r '.query // ""' 2>/dev/null || echo "")
            echo "{\"url\":\"$URL\",\"query\":\"$QUERY\"}"
            ;;
        *)
            echo "{}"
            ;;
    esac
}

# Get tool parameters
TOOL_PARAMS=$(echo "$JSON_INPUT" | jq -r '.parameters // {}' 2>/dev/null || echo "{}")
ACTION_DETAILS=$(process_tool_specific_data "$TOOL_NAME" "$TOOL_PARAMS")

# Create event classification
EVENT_TYPE=""
case "$TOOL_NAME" in
    "Read") EVENT_TYPE="file_read" ;;
    "Write") EVENT_TYPE="file_write" ;;
    "Edit"|"MultiEdit") EVENT_TYPE="file_edit" ;;
    "Bash") EVENT_TYPE="command_execution" ;;
    "Grep"|"Glob") EVENT_TYPE="file_search" ;;
    "Task") EVENT_TYPE="task_delegation" ;;
    "WebFetch"|"WebSearch") EVENT_TYPE="web_request" ;;
    "TodoWrite") EVENT_TYPE="task_management" ;;
    *) EVENT_TYPE="other" ;;
esac

# Security analysis
SECURITY_FLAGS="{\"outside_project_scope\":false,\"sensitive_path\":false}"
if echo "$ACTION_DETAILS" | jq -e '.outside_project_scope == true' >/dev/null 2>&1; then
    SECURITY_FLAGS="{\"outside_project_scope\":true,\"sensitive_path\":false}"
fi

# Check for sensitive file patterns
if echo "$ACTION_DETAILS" | jq -r '.file_path // ""' | grep -qE '\.(env|key|pem|crt|password|secret)$|password|secret|key'; then
    SECURITY_FLAGS=$(echo "$SECURITY_FLAGS" | jq '.sensitive_path = true')
fi

# Create structured log entry
LOG_ENTRY=$(jq -n \
    --arg timestamp "$TIMESTAMP" \
    --arg project "$RESOLVED_PROJECT_NAME" \
    --arg tool "$TOOL_NAME" \
    --arg event_type "$EVENT_TYPE" \
    --arg session_id "$SESSION_ID" \
    --arg hook_event "$HOOK_EVENT" \
    --argjson action_details "$ACTION_DETAILS" \
    --argjson security_flags "$SECURITY_FLAGS" \
    --argjson superclaude_context "$SUPERCLAUDE_CONTEXT" \
    '{
        timestamp: $timestamp,
        project: $project,
        tool_name: $tool,
        event_type: $event_type,
        session_id: $session_id,
        hook_event: $hook_event,
        action_details: $action_details,
        security_flags: $security_flags,
        superclaude_context: $superclaude_context,
        schema_version: "2.0.0"
    }'
)

# Create Loki-compatible payload with project-specific labels
LOKI_PAYLOAD=$(cat << EOF
{
    "streams": [
        {
            "stream": {
                "service": "claude-telemetry",
                "project": "$RESOLVED_PROJECT_NAME",
                "tool": "$TOOL_NAME",
                "event": "$EVENT_TYPE",
                "session": "$SESSION_ID"
            },
            "values": [
                ["$(date +%s%N)", "$(echo "$LOG_ENTRY" | jq -c . | sed 's/"/\\"/g')"]
            ]
        }
    ]
}
EOF
)

# Send to Loki server (fire and forget, don't block if Loki is down)
if [[ -n "$TELEMETRY_SERVER_URL" ]]; then
    curl -s -H "Content-Type: application/json" \
         -XPOST "$TELEMETRY_SERVER_URL/loki/api/v1/push" \
         -d "$LOKI_PAYLOAD" >/dev/null 2>&1 &
fi

# Return success to continue tool execution
echo '{"continue": true}'
exit 0